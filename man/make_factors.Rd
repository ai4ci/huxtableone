% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tableone.R
\name{make_factors}
\alias{make_factors}
\title{Convert discrete data to factors}
\usage{
make_factors(
  df,
  ...,
  .logical = c("yes", "no"),
  .numeric = "{name}={value}",
  .character = NULL
)
}
\arguments{
\item{df}{a data frame}

\item{...}{either a \code{tidyselect} specification or a formula with the right
hand side defining the columns to convert (left hand side is ignored)}

\item{.logical}{(optional) a length 2 vector defining the levels of TRUE, then
FALSE.}

\item{.numeric}{(optional) if provided it must either be a named list e.g.
\code{c(column_name = "{name}:{value}", ..., .default="{value}")} pairs which define the way in which
numeric columns are converted to factor levels. If a single value is given
then all numerics are converted in the same way (this is the default). If
there are some values that you are not certain you want to convert setting
a limit on the maximum number of levels in a generated factor may be a good
idea (i.e. \code{options("tableone.max_discrete_levels"=16)}) otherwise all
values are converted}

\item{.character}{in general character columns are converted into a factor with
the default levels. To explicitly set levels a named list can be given here
which \code{c(colname_1 = c("level_1", "level_2", ...), colname_2 = ...)}}
}
\value{
a dataframe with the columns converted to factors
}
\description{
It is simpler for presentation and sometimes more correct for discrete valued
data to be represented as factors. Such discrete valued data might be logical values,
character values, or numeric values with a limited number of levels (e.g. scores).
this function lets you convert (a subset of) data frame columns into factors
using
}
\examples{
iris \%>\%
  make_factors(tidyselect::ends_with("Length"), .numeric = "{name}={round(value)}") \%>\%
  dplyr::glimpse()

# Convert everything in diamonds to be a factor, rounding all
# the numeric values and converting all the names to upper case
tmp = diamonds \%>\%
  dplyr::mutate(is_colored = color > "F") \%>\%
  make_factors(tidyselect::everything(), .numeric="{toupper(name)}={round(value)}")

# as we included `price` which has very many levels one factor is unuseable with 11602 levels:
length(levels(tmp$price))

# we could explicitly exclude it from the `tidyselect` syntax `...` parameter:
diamonds \%>\% dplyr::mutate(is_colored = color > "F") \%>\%
  make_factors(-price, .numeric="{toupper(name)}={round(value)}") \%>\%
  dplyr::glimpse()

# or alternatively we set a limit on the maximum number of factors, which
# in this example picks up the `depth` and `table` columns as exceeding this
# new limit:

old = options("tableone.max_discrete_levels"=16)
diamonds \%>\% dplyr::mutate(is_colored = color > "F") \%>\%
  make_factors(tidyselect::everything(), .numeric="{toupper(name)}={round(value)}") \%>\%
  dplyr::glimpse()

options(old)

# converting a character vector. Here we specify `.character` as a list giving the
# possible levels of `alpha2`. Values outside of this list are converted to `NA`

set.seed(100)
eg_character = tibble::tibble(
  alpha1 =  sample(letters,50,replace=TRUE),
  alpha2 = sample(LETTERS,50,replace=TRUE)
)

eg_character \%>\%
  make_factors(tidyselect::everything(), .character = list(alpha2 = LETTERS[3:20]))


}
