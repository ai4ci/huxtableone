% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tableone.R
\name{describe_population}
\alias{describe_population}
\title{Describe the population in a summary table}
\usage{
describe_population(
  df,
  ...,
  label_fn = label_extractor(df),
  units = list(),
  override_type = list(),
  layout = "single",
  override_percent_dp = list(),
  override_real_dp = list(),
  font_size = getOption("tableone.font_size", 8),
  font = getOption("tableone.font", "Arial"),
  footer_text = NULL,
  show_binary_value = NULL
)
}
\arguments{
\item{df}{a dataframe of individual observations. Grouping, if present, is ignored.
(n.b. if you wanted to construct multiple summary tables a \code{\link[dplyr:group_map]{dplyr::group_map()}} call
could be used)}

\item{...}{the columns of variables we wish to summarise. This can be given as
a \code{tidyselect} specification (see \code{utils::vignette("syntax", package = "tidyselect")}),
identifying the columns. Alternatively it can be given as a formula of the nature

\code{outcome ~ intervention + covariate_1 + covariate_2 + ...} .

which may be more convenient if you are going on to do a model fit. If the
latter format the left hand side is ignored (outcomes are not usual in
this kind of table).}

\item{label_fn}{(optional) a function for mapping a co-variate column name to
printable label. This is by default a no-operation and the output table
will contain the dataframe column names as labels. A simple alternative
would be some form of \link[dplyr:case_when]{dplyr::case_when} lookup, or a string function such
as \link[stringr:case]{stringr::str_to_sentence}. (N.b. this function must be vectorised).
Any value provided here will be overridden by the
\code{options("tableone.labeller" = my_label_fn)} which allows global setting of
the labeller.}

\item{units}{(optional) a named list of units, following a \verb{c(<colname_1> = "<unit_1>", <colname_2> = "<unit_2>", ...)} format. columns not present in
this list are assumed to have no units. Units may be involved in the
formatting of the summary output.}

\item{override_type}{(optional) a named list of data summary types. The
default type for a column in a data set are calculated using heurisitics
depending on the nature of the data (categorical or continuous), and result
of normality tests. if you want to override this the options are
"subtype_count","median_iqr","mean_sd","skipped" and you
specify this on a column by column bases with a named list (e.g
\code{c("Petal.Width"="mean_sd")}). Overriding the default does not check the
type of data is correct for the summary type and will potentially cause
errors if this is not done correctly.}

\item{layout}{(optional) various layouts are defined as default. As of this
version of \code{tableone} they are
"relaxed","compact","micro","simple","single","missing". The layouts can be
customised using the options \verb{options("tableone.format_list"=list(...)")},
and this is described in more detail in the vignettes.}

\item{override_percent_dp}{(optional) a named list of overrides for the default
precision of formatting percentages, following a \verb{c(<colname_1> = 2, <colname_2> = 4, ...)} format. columns not present in this list
will use the defaults defined in the layout. See the vignette on customisation.}

\item{override_real_dp}{(optional) a named list of overrides for the default
precision of formatting real values, following a \verb{c(<colname_1> = 2, <colname_2> = 4, ...)} format. columns not present in this list
will use the defaults defined in the layout. See the
\code{utils::vignette("customisation", package="tableone")}.}

\item{font_size}{(optional) the font size for the table in points}

\item{font}{(optional) the font family for the table (which will be matched to
closest on your system)}

\item{footer_text}{any text that needs to be added at the end of the table,
setting this to FALSE dsables the whole footer (as does
\code{options("tableone.hide_footer"=TRUE)}).}

\item{show_binary_value}{if set this will filter the display of covariates where the number of possibilities
is exactly 2 to this value.}
}
\value{
a \code{huxtable} formatted table.
}
\description{
The population description is a simple summary of the co-variates in a data set
with no reference to outcome, and not comparing intervention (although it might
contain intervention rates.) It will report summary statistics for continuous
and counts for categorical data,
}
\examples{
# the heuristics detect that Petals in the iris data set are not normally
# distributed and hence report median and IQR:
iris \%>\% describe_population(tidyselect::everything())

# Overriding the heuristics is possible:
iris \%>\% describe_population(
  tidyselect::everything(),
  override_type = c(Petal.Length = "mean_sd", Petal.Width = "mean_sd")
)

# The counts sometimes seem redundant if there is no missing information:
diamonds \%>\% describe_population(tidyselect::everything())

# however in a data set with missing values the denominators are important:
missing_diamonds \%>\% describe_population(tidyselect::everything())

# for factor levels we can make the missing values more explicit
missing_diamonds \%>\% explicit_na() \%>\%
  describe_population(tidyselect::everything())

# in the output above the price variable is not # presented the way we would
# like so here we override the number of decimal places shown for the price
# variable while we are at it we will use a mid point for the decimal point,
# and make the variable labels sentence case.

old = options("tableone.dp"="\u00B7")
missing_diamonds \%>\%
  explicit_na() \%>\%
  describe_population(
    tidyselect::everything(),
    label_fn=stringr::str_to_sentence,
    override_real_dp=list(price=6)
  )
options(old)
}
