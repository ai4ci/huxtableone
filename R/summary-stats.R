## Summary stats ----

# generates a summary of a grouped dataframe with x column for data for discrete
# counts.
# df_shape = diamonds %>% dplyr::group_by(cut) %>% .get_shape(cols = ggplot2::vars(color))
# grp_df = df_shape$.source[[1]]
# .subtype_count(grp_df)
.subtype_count = function(grp_df) {
  if (is.logical(grp_df$x)) grp_df = grp_df %>% dplyr::mutate(x = factor(ifelse(x,"true","false")))
  if (is.numeric(grp_df$x)) grp_df = grp_df %>% dplyr::mutate(x = factor(as.character(x)))
  grp_df %>% dplyr::group_modify(function(d,g,...) {
    col = d$x
    tibble::enframe(table(col),name = "level",value = "n") %>%
      dplyr::mutate(level = factor(level, levels=levels(grp_df$x)), x = as.integer(n), n = sum(n)) %>%
      dplyr::mutate(binom::binom.confint(x=x, n=n, methods="wilson")) %>%
      dplyr::rename(N=n,n=x, prob.0.5=mean, prob.0.025=lower, prob.0.975=upper) %>%
      dplyr::mutate(.order2 = dplyr::row_number()) %>%
      dplyr::select(-method)
  })
}

# generates a summary of a grouped dataframe with x column for data for
# non normal continuous data
# grp_df = iris %>% dplyr::group_by(Species) %>% dplyr::select(x = Petal.Width)
# .median_iqr(grp_df)
.median_iqr = function(grp_df) {
  quantiles = c(0.025,0.05,0.25,0.5,0.75,0.95,0.975)
  grp_df %>% dplyr::group_modify(function(d,g,...) {
    col = d$x
    tibble::as_tibble_row(
      stats::quantile(col, quantiles, na.rm=TRUE) %>% magrittr::set_names(sprintf("q.%1g", quantiles))
    ) %>% dplyr::mutate(
      n = length(stats::na.omit(col)),
      N = length(col),
      .order2 = 1
    )
  })
}

# generates a summary of a grouped dataframe with x column for data for
# normal continuous data
# grp_df = iris %>% dplyr::group_by(Species) %>% dplyr::select(x = Petal.Width)
# .mean_sd(grp_df)
.mean_sd = function(grp_df) {
  grp_df %>% dplyr::summarise(
    mean = mean(x, na.rm = TRUE),
    sd = stats::sd(x, na.rm = TRUE),
    n = length(stats::na.omit(x)),
    N = length(x),
    .order2 = 1,
    .groups = "keep"
  )
}

# generates a summary of a grouped dataframe with x column for data for
# none of the above.
# grp_df = iris %>% dplyr::group_by(Species) %>% dplyr::select(x = Petal.Width)
# .skipped(grp_df)
.skipped = function(grp_df) {
  grp_df %>% dplyr::summarise(
    n = length(stats::na.omit(x)),
    N = length(x),
    .order2 = 1,
    .groups = "keep"
  )
}

.summary_types= list(
  "subtype_count" = .subtype_count,
  "median_iqr" = .median_iqr,
  "mean_sd" = .mean_sd,
  "skipped" = .skipped
)

# generate summary stats for each of the columns of a dataframe, depending on
# the nature of that column (and determined by .get_shape).
# df_shape is as generated by .get_shape()
# df_shape = diamonds %>%  dplyr::mutate(is_clear = ifelse(clarity>"VS2","clear","less clear")) %>% dplyr::group_by(is_clear) %>% .get_shape()
# df_shape %>% .summary_stats()
# df_shape = iris %>% dplyr::group_by(Species) %>% .get_shape()
# df_shape %>% .summary_stats()
.summary_stats = function(df_shape, override_type = list() ) {

  normality_signif = getOption("tableone.normality_significance",0.005)
  override_type = as.list(override_type)

  if (!".summary_type" %in% colnames(df_shape)) {
    # what kind of summary stats?
    # TODO: as a function that takes the dataframe?
    df_shape = df_shape %>% dplyr::mutate(
      .summary_type = dplyr::case_when(
        .type == "categorical" ~ "subtype_count",
        .type == "continuous" & .p_is_normal >= normality_signif ~ "mean_sd",
        .type == "continuous" ~ "median_iqr",
        TRUE ~ "skipped"
      )
    )
    # See if user wants to override?
    if (length(override_type) > 0) {
      if (any(!override_type %in% names(.summary_types)))
        stop("override types must be one of ", paste0(names(.summary_types),collapse=", "))
      # override_type = list("multinom_class"="mean_sd")
      override = tibble::tibble(
        .name = names(override_type),
        .override_type = unlist(override_type)
      )
      df_shape = df_shape %>% dplyr::left_join(override, by=".name") %>%
        dplyr::mutate(.summary_type = ifelse(!is.na(.override_type), .override_type, .summary_type)) %>%
        dplyr::select(-.override_type)
    }
  }

  df_shape$.summary_data = list(rep(NA,nrow(df_shape)))
  for (i in 1:nrow(df_shape)) {
    # get dataframe row as a list
    tmp = df_shape %>% purrr::map(~ .x[[i]])
    message(tmp$.summary_type, " summary for ",tmp$.label)
    fun = .summary_types[[tmp$.summary_type]]
    d = tmp$.source
    result = fun(d)
    df_shape$.summary_data[[i]] = result
  }

  df_shape = df_shape %>% dplyr::mutate(
      N_total = sapply(.content, length),
      N_present = sapply(.content, function(x) length(stats::na.omit(x)))
    )

  return(df_shape)
}

# print the summary stats for each of the columns of a dataframe, into
# a prettified table with control for layout as defined in default.format
# this can be overwritten in "tableone.format_list" option
# df_shape = diamonds %>%  dplyr::mutate(is_clear = ifelse(clarity>"VS2","clear","less clear")) %>% dplyr::group_by(is_clear) %>% .get_shape()
# df_summary = df_shape %>% .summary_stats()
# df_summary %>% .format_summary()
.format_summary = function(df_summary, layout = names(default.format), override_percent_dp = list(), override_real_dp = list() ) {

  layout = match.arg(layout)
  override_percent_dp = as.list(override_percent_dp)
  override_real_dp = as.list(override_real_dp)

  format = getOption("tableone.format_list", default.format[[layout]])
  if (!".glue" %in% colnames(df_summary)) {
    df_summary = df_summary %>% dplyr::mutate(
      .glue = format[.summary_type]
    )
  }

  # Override decimal points
  if (length(override_percent_dp) > 0) {
    override = tibble::tibble(
      .name = names(override_percent_dp),
      .percent_dp = unlist(override_percent_dp)
    )
    df_summary = df_summary %>% dplyr::left_join(override, by=".name")
  } else {
    df_summary = df_summary %>% dplyr::mutate(.percent_dp = NA)
  }

  if (length(override_real_dp) > 0) {
    override = tibble::tibble(
      .name = names(override_real_dp),
      .real_dp = unlist(override_real_dp)
    )
    df_summary = df_summary %>% dplyr::left_join(override, by=".name")
  } else {
    df_summary = df_summary %>% dplyr::mutate(.real_dp = NA)
  }



  # why does the R world have such a dim view of loops
  # This is basically much more tractable than the equivalent in
  # map / lapply madness and worked immediately.
  df_summary = df_summary %>% dplyr::mutate(.labelled_data = list(rep(tibble::tibble(),nrow(df_summary))))

  for (i in 1:nrow(df_summary)) {
    df_row = df_summary %>% purrr::map(~ .x[[i]])

    data = df_row$.summary_data %>% dplyr::mutate(
      # add in unit from above.
      unit = df_row$.unit
    )
    grps = data %>% dplyr::groups()
    glue = df_row$.glue


    outcols = c()
    for (newcol in names(glue)) {
      thisglue = glue[[newcol]]
      thisglue = .adjust_fmt(thisglue, percent = df_row$.percent_dp, real = df_row$.real_dp)
      # data = data %>% dplyr::mutate(!!newcol := glue::glue(thisglue))
      # TODO: This could work - using a "value (N = {N_total})" to put some
      # stats into the column name (e.g. N or units) the column name but the columns
      # will not be comparable between different groups and maybe will cause issues
      newcol_name = as.character(glue::glue_data(df_row, newcol))
      data = data %>% dplyr::mutate(!!newcol_name := glue::glue(thisglue))
      outcols = c(outcols,newcol_name)
    }
    df_summary$.labelled_data[[i]] = data %>% dplyr::select(!!!grps, tidyselect::any_of(outcols), .order2)
  }

  tmp = suppressMessages(
    df_summary %>% dplyr::select(variable = .label, .order, .labelled_data) %>%
      tidyr::unnest(.labelled_data) %>%
      dplyr::relocate(!!!grps) %>%
      dplyr::arrange(!!!grps, .order, .order2) %>%
      dplyr::select(-.order,-.order2)
  )
  return(structure(tmp, methods = get_footer_text(df_summary)))

}
